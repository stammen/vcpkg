diff --git a/configure.ac b/configure.ac
index 9846a4c..bb69d19 100644
--- a/configure.ac
+++ b/configure.ac
@@ -45,6 +45,7 @@ AC_SUBST([CP_CXX_LIB_VERSION])
 # Automake initialization
 # -----------------------
 AM_INIT_AUTOMAKE([foreign])
+m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])
 AM_GNU_GETTEXT([external])
 AM_GNU_GETTEXT_VERSION([0.16.1])
 
@@ -106,15 +107,15 @@ if test "$enable_threads" != no; then
     ( test -z "$enable_threads" || test "$enable_threads" = Posix ); then
     AC_MSG_CHECKING([for Posix threads])
     AC_LINK_IFELSE(
-[#include <pthread.h>
+[AC_LANG_SOURCE([#include <pthread.h>
 
-int main(int argc, char *argv[]) {
+int main(int argc, char **argv) {
 	pthread_mutex_t mutex;
 	
 	pthread_mutex_init(&mutex, NULL);
 	return 0;
 }
-], [AC_MSG_RESULT([yes])
+])], [AC_MSG_RESULT([yes])
 cp_threads=Posix], AC_MSG_RESULT([no]))
   fi
   
@@ -123,13 +124,13 @@ cp_threads=Posix], AC_MSG_RESULT([no]))
     ( test -z "$enable_threads" || test "$enable_threads" = Windows ); then
     AC_MSG_CHECKING([for Windows threads])
     AC_LINK_IFELSE(
-[#include <windows.h>
+[AC_LANG_SOURCE([#include <windows.h>
 
-int main(int argc, char *argv[]) {
+int main(int argc, char **argv) {
   CreateMutex(NULL, FALSE, NULL);
   return 0;
 }
-], [AC_MSG_RESULT([yes])
+])], [AC_MSG_RESULT([yes])
 cp_threads=Windows], AC_MSG_RESULT([no]))
   fi
   
@@ -165,7 +166,8 @@ dlmechanism=none
 if test "$with_dlopen" != no && test "$with_libltdl" != yes; then
   AC_CHECK_HEADER([dlfcn.h],
     AC_CHECK_LIB([dl], [dlopen],
-      [LIBS_LIBCPLUFF="-ldl $LIBS_LIBCPLUFF"; dlmechanism=dlopen]))
+      [LIBS_LIBCPLUFF="-ldl $LIBS_LIBCPLUFF"; dlmechanism=dlopen],
+	AC_CHECK_LIB([c], [dlopen], [dlmechanism=dlopen])))
 fi
 if test "$dlmechanism" = none && test "$with_libltdl" != no && test "$with_dlopen" != yes; then  
   AC_CHECK_HEADER([ltdl.h],
diff --git a/kazlib/hash.h b/kazlib/hash.h
index 1fbd246..50297ee 100644
--- a/kazlib/hash.h
+++ b/kazlib/hash.h
@@ -27,7 +27,11 @@
 #ifndef HASH_H
 #define HASH_H
 
+#ifdef _WIN32
+#include "../libcpluff/win32/cpluffdef.h"
+#else
 #include "../libcpluff/cpluffdef.h"
+#endif
 
 #include <limits.h>
 #ifdef KAZLIB_SIDEEFFECT_DEBUG
diff --git a/kazlib/list.h b/kazlib/list.h
index c449acb..ccad262 100644
--- a/kazlib/list.h
+++ b/kazlib/list.h
@@ -27,7 +27,11 @@
 #ifndef LIST_H
 #define LIST_H
 
+#ifdef _WIN32
+#include "../libcpluff/win32/cpluffdef.h"
+#else
 #include "../libcpluff/cpluffdef.h"
+#endif
 
 #include <limits.h>
 
diff --git a/libcpluff/context.c b/libcpluff/context.c
index 784d1b4..529574e 100644
--- a/libcpluff/context.c
+++ b/libcpluff/context.c
@@ -53,7 +53,7 @@ static list_t *contexts = NULL;
 
 // Generic 
 
-static void free_plugin_env(cp_plugin_env_t *env) {
+CP_HIDDEN void free_plugin_env(cp_plugin_env_t *env) {
 	assert(env != NULL);
 	
 	// Free environment data
diff --git a/libcpluff/cpluff.h b/libcpluff/cpluff.h
index 0f9797d..584ed01 100644
--- a/libcpluff/cpluff.h
+++ b/libcpluff/cpluff.h
@@ -37,8 +37,12 @@
  * @defgroup cDefines Defines
  * Preprocessor defines.
  */
- 
-#include <cpluffdef.h>
+
+#ifdef _WIN32
+#include "win32/cpluffdef.h"
+#else
+#include "cpluffdef.h"
+#endif
 
 #ifdef __cplusplus
 extern "C" {
@@ -1076,6 +1080,25 @@ CP_C_API int cp_is_logged(cp_context_t *ctx, cp_log_severity_t severity) CP_GCC_
 CP_C_API cp_plugin_info_t * cp_load_plugin_descriptor(cp_context_t *ctx, const char *path, cp_status_t *status) CP_GCC_NONNULL(1, 2);
 
 /**
+ * Loads a plug-in descriptor from the specified block of memory and returns
+ * information about the plug-in. The plug-in descriptor
+ * is validated during loading. Possible loading errors are reported via the
+ * specified plug-in context. The plug-in is not installed to the context.
+ * If operation fails or the descriptor
+ * is invalid then NULL is returned. The caller must release the returned
+ * information by calling ::cp_release_plugin_info when it does not
+ * need the information anymore.
+ * The returned plug-in information must not be modified.
+ * 
+ * @param ctx the plug-in context
+ * @param buffer the buffer containing the plug-in descriptor.
+ * @param buffer_len the length of the buffer.
+ * @param status a pointer to the location where status code is to be stored, or NULL
+ * @return pointer to the information structure or NULL if error occurs
+ */
+CP_C_API cp_plugin_info_t * cp_load_plugin_descriptor_from_memory(cp_context_t *context, const char *buffer, unsigned int buffer_len, cp_status_t *error) CP_GCC_NONNULL(1, 2);
+
+/**
  * Installs the plug-in described by the specified plug-in information
  * structure to the specified plug-in context. The plug-in information
  * must have been loaded using ::cp_load_plugin_descriptor with the same
diff --git a/libcpluff/internal.h b/libcpluff/internal.h
index 91989e8..5f57617 100644
--- a/libcpluff/internal.h
+++ b/libcpluff/internal.h
@@ -83,7 +83,17 @@ extern "C" {
  * Macros
  * ----------------------------------------------------------------------*/
 
-#if defined(DLOPEN_POSIX)
+#if defined(_WIN32)
+#define DLHANDLE void *
+#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY != WINAPI_FAMILY_DESKTOP_APP)
+#define DLOPEN(name) LoadPackagedLibrary(name, 0)
+#else
+#define DLOPEN(name) LoadLibraryA(name)
+#endif
+#define DLSYM(handle, symbol) GetProcAddress(handle, symbol)
+#define DLCLOSE(handle) CloseHandle(handle)
+#define DLERROR() "WIN32 - TODO"
+#elif defined(DLOPEN_POSIX)
 #define DLHANDLE void *
 #define DLOPEN(name) dlopen((name), RTLD_LAZY | RTLD_GLOBAL)
 #define DLSYM(handle, symbol) dlsym((handle), (symbol))
diff --git a/libcpluff/pcontrol.c b/libcpluff/pcontrol.c
index 83a24cb..97480c5 100644
--- a/libcpluff/pcontrol.c
+++ b/libcpluff/pcontrol.c
@@ -40,7 +40,9 @@
 #include "defines.h"
 #include "util.h"
 #include "internal.h"
-
+#ifdef _WIN32
+#include <windows.h>
+#endif
 
 /* ------------------------------------------------------------------------
  * Function definitions
@@ -64,7 +66,7 @@ static void assert_processed_zero(cp_context_t *context) {
 #endif
 
 static void unregister_extensions(cp_context_t *context, cp_plugin_info_t *plugin) {
-	int i;
+	unsigned int i;
 	
 	for (i = 0; i < plugin->num_ext_points; i++) {
 		cp_ext_point_t *ep = plugin->ext_points + i;
@@ -106,7 +108,7 @@ CP_C_API cp_status_t cp_install_plugin(cp_context_t *context, cp_plugin_info_t *
 	cp_plugin_t *rp = NULL;
 	cp_status_t status = CP_OK;
 	cpi_plugin_event_t event;
-	int i;
+	unsigned int i;
 
 	CHECK_NOT_NULL(context);
 	CHECK_NOT_NULL(plugin);
@@ -312,7 +314,13 @@ static int resolve_plugin_runtime(cp_context_t *context, cp_plugin_t *plugin) {
 		strcpy(rlpath + ppath_len + 1 + lname_len, CP_SHREXT);
 		
 		// Open the plug-in runtime library 
+#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY != WINAPI_FAMILY_DESKTOP_APP)
+		WCHAR wPath[MAX_PATH];
+		MultiByteToWideChar(CP_ACP, 0, rlpath, -1, (LPWSTR)wPath, MAX_PATH);
+		plugin->runtime_lib = DLOPEN(wPath);
+#else
 		plugin->runtime_lib = DLOPEN(rlpath);
+#endif
 		if (plugin->runtime_lib == NULL) {
 			const char *error = DLERROR();
 			if (error == NULL) {
@@ -418,7 +426,7 @@ static int resolve_plugin_prel_rec(cp_context_t *context, cp_plugin_t *plugin) {
 	cp_status_t status = CP_OK;
 	int error_reported = 0;
 	lnode_t *node = NULL;
-	int i;
+	unsigned int i;
 
 	// Check if already resolved
 	if (plugin->state >= CP_PLUGIN_RESOLVED) {
@@ -1089,7 +1097,7 @@ static void free_extension_content(cp_extension_t *extension) {
 }
 
 static void free_cfg_element_content(cp_cfg_element_t *ce) {
-	int i;
+	unsigned int i;
 
 	assert(ce != NULL);
 	free(ce->name);
@@ -1105,7 +1113,7 @@ static void free_cfg_element_content(cp_cfg_element_t *ce) {
 }
 
 CP_HIDDEN void cpi_free_plugin(cp_plugin_info_t *plugin) {
-	int i;
+	unsigned int i;
 	
 	assert(plugin != NULL);
 	free(plugin->name);
diff --git a/libcpluff/pinfo.c b/libcpluff/pinfo.c
index 2bd5a45..cfbf049 100644
--- a/libcpluff/pinfo.c
+++ b/libcpluff/pinfo.c
@@ -194,7 +194,7 @@ CP_C_API cp_plugin_info_t * cp_get_plugin_info(cp_context_t *context, const char
 		// Lookup plug-in information
 		if (id != NULL) {
 			if ((node = hash_lookup(context->env->plugins, id)) == NULL) {
-				cpi_warnf(context, N_("Could not return information about unknown plug-in %s."), id);
+				//cpi_warnf(context, N_("Could not return information about unknown plug-in %s."), id);
 				status = CP_ERR_UNKNOWN;
 				break;
 			}
@@ -663,7 +663,7 @@ static cp_cfg_element_t * lookup_cfg_element(cp_cfg_element_t *base, const char
 		if (end - start == 2 && !strncmp(path + start, "..", 2)) {
 			base = base->parent;
 		} else {
-			int i;
+			unsigned int i;
 			int found = 0;
 			
 			for (i = 0; !found && i < base->num_children; i++) {
@@ -707,7 +707,7 @@ CP_C_API char * cp_lookup_cfg_value(cp_cfg_element_t *base, const char *path) {
 		if (attr == NULL) {
 			return e->value;
 		} else {
-			int i;
+			unsigned int i;
 			
 			for (i = 0; i < e->num_atts; i++) {
 				if (!strcmp(attr, e->atts[2*i])) {
diff --git a/libcpluff/ploader.c b/libcpluff/ploader.c
index 648c2bb..6c9a741 100644
--- a/libcpluff/ploader.c
+++ b/libcpluff/ploader.c
@@ -57,7 +57,7 @@
 #define CP_CFG_ELEMENT_VALUE_INITSIZE 64
 
 /// Plugin descriptor name 
-#define CP_PLUGIN_DESCRIPTOR "plugin.xml"
+#define CP_PLUGIN_DESCRIPTOR "addon.xml"
 
 
 /* ------------------------------------------------------------------------
@@ -520,7 +520,7 @@ static void CP_XMLCALL start_element_handler(
 	static const XML_Char * const opt_bwcompatibility_atts[] = { "abi", "api", NULL };
 	static const XML_Char * const req_cpluff_atts[] = { "version", NULL };
 	static const XML_Char * const opt_cpluff_atts[] = { NULL };
-	static const XML_Char * const req_import_atts[] = { "plugin", NULL };
+	static const XML_Char * const req_import_atts[] = { "addon", NULL };
 	static const XML_Char * const opt_import_atts[] = { "version", "optional", NULL };
 	static const XML_Char * const req_runtime_atts[] = { "library", NULL };
 	static const XML_Char * const opt_runtime_atts[] = { "funcs", NULL };
@@ -535,7 +535,7 @@ static void CP_XMLCALL start_element_handler(
 	switch (plcontext->state) {
 
 		case PARSER_BEGIN:
-			if (!strcmp(name, "plugin")) {
+			if (!strcmp(name, "addon")) {
 				plcontext->state = PARSER_PLUGIN;
 				if (!check_attributes(plcontext, name, atts,
 						req_plugin_atts, opt_plugin_atts)) {
@@ -745,7 +745,7 @@ static void CP_XMLCALL start_element_handler(
 					import->plugin_id = NULL;
 					import->version = NULL;
 					for (i = 0; atts[i] != NULL; i += 2) {
-						if (!strcmp(atts[i], "plugin")) {
+						if (!strcmp(atts[i], "addon")) {
 							import->plugin_id
 								= parser_strdup(plcontext, atts[i+1]);
 						} else if (!strcmp(atts[i], "version")) {
@@ -828,7 +828,7 @@ static void CP_XMLCALL end_element_handler(
 	switch (plcontext->state) {
 
 		case PARSER_PLUGIN:
-			if (!strcmp(name, "plugin")) {
+			if (!strcmp(name, "addon")) {
 				
 				// Readjust memory allocated for extension points, if necessary 
 				if (plcontext->ext_points_size != plcontext->plugin->num_ext_points) {
@@ -1130,7 +1130,7 @@ CP_C_API cp_plugin_info_t * cp_load_plugin_descriptor(cp_context_t *context, con
 					N_("Plug-in descriptor in %s is invalid."), path);
 				break;
 			case CP_ERR_IO:
-				cpi_errorf(context,
+				cpi_debugf(context,
 					N_("An I/O error occurred while loading a plug-in descriptor from %s."), path);
 				break;
 			case CP_ERR_RESOURCE:
@@ -1184,3 +1184,182 @@ CP_C_API cp_plugin_info_t * cp_load_plugin_descriptor(cp_context_t *context, con
 
 	return plugin;
 }
+
+CP_C_API cp_plugin_info_t * cp_load_plugin_descriptor_from_memory(cp_context_t *context, const char *buffer, unsigned int buffer_len, cp_status_t *error) {
+	char *file = NULL;
+  const char *path = "memory";
+	cp_status_t status = CP_OK;
+	XML_Parser parser = NULL;
+	ploader_context_t *plcontext = NULL;
+	cp_plugin_info_t *plugin = NULL;
+
+	CHECK_NOT_NULL(context);
+	CHECK_NOT_NULL(buffer);
+	cpi_lock_context(context);
+	cpi_check_invocation(context, CPI_CF_ANY, __func__);
+	do {
+		int path_len = 6;
+		file = malloc((path_len + 1) * sizeof(char));
+		if (file == NULL) {
+			status = CP_ERR_RESOURCE;
+			break;
+		}
+    strcpy(file, path);
+
+		// Initialize the XML parsing 
+		parser = XML_ParserCreate(NULL);
+		if (parser == NULL) {
+			status = CP_ERR_RESOURCE;
+			break;
+		}
+		XML_SetElementHandler(parser,
+			start_element_handler,
+			end_element_handler);
+		
+		// Initialize the parsing context 
+		if ((plcontext = malloc(sizeof(ploader_context_t))) == NULL) {
+			status = CP_ERR_RESOURCE;
+			break;
+		}
+		memset(plcontext, 0, sizeof(ploader_context_t));
+		if ((plcontext->plugin = malloc(sizeof(cp_plugin_info_t))) == NULL) {
+			status = CP_ERR_RESOURCE;
+			break;
+		}
+		plcontext->context = context;
+		plcontext->configuration = NULL;
+		plcontext->value = NULL;
+		plcontext->parser = parser;
+		plcontext->file = file;
+		plcontext->state = PARSER_BEGIN;
+		memset(plcontext->plugin, 0, sizeof(cp_plugin_info_t));
+		plcontext->plugin->name = NULL;
+		plcontext->plugin->identifier = NULL;
+		plcontext->plugin->version = NULL;
+		plcontext->plugin->provider_name = NULL;
+		plcontext->plugin->abi_bw_compatibility = NULL;
+		plcontext->plugin->api_bw_compatibility = NULL;
+		plcontext->plugin->plugin_path = NULL;
+		plcontext->plugin->req_cpluff_version = NULL;
+		plcontext->plugin->imports = NULL;
+		plcontext->plugin->runtime_lib_name = NULL;
+		plcontext->plugin->runtime_funcs_symbol = NULL;
+		plcontext->plugin->ext_points = NULL;
+		plcontext->plugin->extensions = NULL;
+		XML_SetUserData(parser, plcontext);
+
+		// Parse the plug-in descriptor 
+    do {
+		  void *xml_buffer;
+		  int i;
+  		
+		  // Get buffer from Expat 
+		  if ((xml_buffer = XML_GetBuffer(parser, buffer_len))
+			  == NULL) {
+			  status = CP_ERR_RESOURCE;
+			  break;
+		  }
+  		
+		  // Read data into buffer
+      memcpy(xml_buffer, buffer, buffer_len);
+
+		  // Parse the data 
+		  if (!(i = XML_ParseBuffer(parser, buffer_len, 1))
+			  && context != NULL) {
+			  cpi_lock_context(context);
+			  cpi_errorf(context,
+				  N_("XML parsing error in %s, line %d, column %d (%s)."),
+				  file,
+				  XML_GetErrorLineNumber(parser),
+				  XML_GetErrorColumnNumber(parser) + 1,
+				  XML_ErrorString(XML_GetErrorCode(parser)));
+			  cpi_unlock_context(context);
+		  }
+		  if (!i || plcontext->state == PARSER_ERROR) {
+			  status = CP_ERR_MALFORMED;
+			  break;
+		  }
+    } while (0);
+		if (status == CP_OK) {
+			if (plcontext->state != PARSER_END || plcontext->error_count > 0) {
+				status = CP_ERR_MALFORMED;
+			}
+			if (plcontext->resource_error_count > 0) {
+				status = CP_ERR_RESOURCE;
+			}
+		}
+		if (status != CP_OK) {
+			break;
+		}
+    
+		// Initialize the plug-in path 
+		*(file + path_len) = '\0';
+		plcontext->plugin->plugin_path = file;
+		file = NULL;
+		
+		// Increase plug-in usage count
+		if ((status = cpi_register_info(context, plcontext->plugin, (void (*)(cp_context_t *, void *)) dealloc_plugin_info)) != CP_OK) {
+			break;
+		}
+		
+	} while (0);
+
+	// Report possible errors
+	if (status != CP_OK) {
+		switch (status) {
+			case CP_ERR_MALFORMED:
+				cpi_errorf(context,
+					N_("Plug-in descriptor in %s is invalid."), path);
+				break;
+			case CP_ERR_IO:
+				cpi_debugf(context,
+					N_("An I/O error occurred while loading a plug-in descriptor from %s."), path);
+				break;
+			case CP_ERR_RESOURCE:
+				cpi_errorf(context,
+					N_("Insufficient system resources to load a plug-in descriptor from %s."), path);
+				break;
+			default:
+				cpi_errorf(context,
+					N_("Failed to load a plug-in descriptor from %s."), path);
+				break;
+		}
+	}
+	cpi_unlock_context(context);
+
+	// Release persistently allocated data on failure 
+	if (status != CP_OK) {
+		if (file != NULL) {
+			free(file);
+			file = NULL;
+		}
+		if (plcontext != NULL && plcontext->plugin != NULL) {
+			cpi_free_plugin(plcontext->plugin);
+			plcontext->plugin = NULL;
+		}
+	}
+	
+	// Otherwise copy the plug-in pointer
+	else {
+		plugin = plcontext->plugin;
+	}
+
+	// Release data allocated for parsing 
+	if (parser != NULL) {
+		XML_ParserFree(parser);
+	}
+	if (plcontext != NULL) {
+		if (plcontext->value != NULL) {
+			free(plcontext->value);
+		}
+		free(plcontext);
+		plcontext = NULL;
+	}
+
+	// Return error code
+	if (error != NULL) {
+		*error = status;
+	}
+
+	return plugin;
+}
diff --git a/libcpluff/pscan.c b/libcpluff/pscan.c
index 38b3297..f062291 100644
--- a/libcpluff/pscan.c
+++ b/libcpluff/pscan.c
@@ -33,7 +33,6 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <dirent.h>
-#include <errno.h>
 #include "cpluff.h"
 #include "defines.h"
 #include "util.h"
@@ -269,13 +268,13 @@ CP_C_API cp_status_t cp_scan_plugins(cp_context_t *context, int flags) {
 	// Report error
 	switch (status) {
 		case CP_OK:
-			cpi_debug(context, N_("Plug-in scan has completed successfully."));
+			cpi_info(context, N_("Plug-in scan has completed successfully."));
 			break;
 		case CP_ERR_RESOURCE:
 			cpi_error(context, N_("Could not scan plug-ins due to insufficient system resources."));
 			break;
 		default:
-			cpi_error(context, N_("Could not scan plug-ins."));
+			cpi_warn(context, N_("Not all directories were successfully scanned."));
 			break;
 	}
 	cpi_unlock_context(context);
diff --git a/libcpluff/psymbol.c b/libcpluff/psymbol.c
index ccf9ea6..632b087 100644
--- a/libcpluff/psymbol.c
+++ b/libcpluff/psymbol.c
@@ -33,6 +33,9 @@
 #include "defines.h"
 #include "internal.h"
 #include "util.h"
+#ifdef _WIN32
+#include <windows.h>
+#endif
 
 
 /* ------------------------------------------------------------------------
diff --git a/libcpluff/util.c b/libcpluff/util.c
index 493b3f0..c4bf501 100644
--- a/libcpluff/util.c
+++ b/libcpluff/util.c
@@ -153,6 +153,7 @@ static int vercmp_num_value(const char *v, const char *vn) {
 CP_HIDDEN int cpi_vercmp(const char *v1, const char *v2) {
 	const char *v1n;
 	const char *v2n;
+	int diff;
 	
 	// Check for NULL versions
 	if (v1 == NULL && v2 != NULL) {
@@ -182,7 +183,7 @@ CP_HIDDEN int cpi_vercmp(const char *v1, const char *v2) {
 			if (v2 < v2n) {
 				c2 = *v2++;
 			}
-			int diff = vercmp_char_value(c1) - vercmp_char_value(c2);
+			diff = vercmp_char_value(c1) - vercmp_char_value(c2);
 			if (diff != 0) {
 				return diff;
 			}
